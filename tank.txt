# --- パラメータ設定 ---
# 物理パラメータ
D <- 1.0e-10       # DMSOの繊維内拡散係数 (m^2/s) - 例: 典型的な液体中の低分子の値
R <- 0.0005        # 繊維の半径 (m) - 例: 0.5 mm
C_fiber_in <- 0.1  # 繊維の初期DMSO濃度 (kg/m^3 または mol/m^3 など単位を統一) - 例
C_tank_in <- 0.01  # 槽への流入液のDMSO濃度 (C_fiber_in と同じ単位) - 例

# 操作パラメータ
Q_in <- 1.0e-5     # 槽への流入流量 (m^3/s) - 例: 10 mL/s
L <- 1.0           # 槽内の繊維経路長 (m) - 例
v_fiber <- 0.01    # 繊維の移動速度 (m/s) - 例: 1 cm/s

# 計算パラメータ
n_terms <- 50      # ベッセル級数の項数 (十分な精度を得るために調整)

# --- J0(x) = 0 の根 (lambda_n) の計算 ---
# J0(x)=0 の根を数値的に求める関数 (uniroot を使用)
find_J0_roots <- function(n_roots) {
  roots <- numeric(n_roots)
  # 根のおおよその位置 (n - 1/4) * pi を目安に探索区間を設定
  for (i in 1:n_roots) {
    # 探索区間: 前の根より大きく、おおよその位置の周辺
    lower_bound <- if (i == 1) 0 else roots[i-1] + 1e-6 # Avoid starting exactly at previous root or 0
    # upper_bound <- (i + 1) * pi # Ensure the root is within the interval
    approx_root = (i - 0.25) * pi
    interval = c(max(lower_bound, approx_root - pi), approx_root + pi) # Search around approx location

    # unirootで根を探す (besselJはRの標準関数)
    # エラー処理を追加
    res <- try(uniroot(function(x) besselJ(x, nu = 0), interval = interval, tol = 1e-9), silent = TRUE)

    if (inherits(res, "try-error")) {
      # 区間を広げて再試行
       warning(paste("Root finding failed for n=", i, "in interval", paste(round(interval,2), collapse=", "), ". Trying wider interval."))
       interval = c(lower_bound, (i + 2)*pi) # Wider interval
       res <- try(uniroot(function(x) besselJ(x, nu = 0), interval = interval, tol = 1e-9), silent = TRUE)
       if (inherits(res, "try-error")){
           stop(paste("Failed to find root for n=", i))
       } else {
            roots[i] <- res$root
       }
    } else {
      roots[i] <- res$root
    }
  }
  return(roots)
}

# 必要な数の根を計算
lambda_n <- find_J0_roots(n_terms)

# --- 主要な計算 ---
# 槽外への流出流量 (定常状態、体積一定なら流入と同じ)
Q_out <- Q_in

# 繊維の槽内滞留時間
t_residence <- L / v_fiber

# 繊維の断面積
A_fiber <- pi * R^2

# 繊維の体積流量
V_dot_fiber <- A_fiber * v_fiber

# 無次元時間 (フーリエ数 Fo_m)
Fo_m <- D * t_residence / R^2

# 級数和 F(t_residence) の計算
# F = sum_{n=1}^N (4 / lambda_n^2) * exp(-lambda_n^2 * Fo_m)
# Rのベクトル化機能を利用して高速に計算
series_terms <- (4 / lambda_n^2) * exp(-lambda_n^2 * Fo_m)
F_t_residence <- sum(series_terms)

# 繊維から除去されるDMSOの割合 (1 - F)
# 物理的に0から1の範囲に収める
fraction_removed <- max(0, min(1, 1 - F_t_residence))

# 定常状態の槽内濃度 C_tank の計算
numerator <- Q_in * C_tank_in + V_dot_fiber * C_fiber_in * fraction_removed
denominator <- Q_out + V_dot_fiber * fraction_removed

# ゼロ割防止
if (abs(denominator) < .Machine$double.eps^0.5) { # 少し緩い条件でチェック
  # 分子もゼロに近い場合（例：流量ゼロ、濃度差ゼロ）は入力濃度と同じなど、状況による
  if (abs(numerator) < .Machine$double.eps^0.5) {
    C_tank_steady_state <- C_tank_in # または C_fiber_in など、初期条件や物理的状況で判断
    warning("Denominator and numerator are close to zero. Result might depend on initial assumptions.")
  } else {
    C_tank_steady_state <- Inf # 物理的に発散するケースを示唆
    warning("Denominator close to zero, potential issue (e.g., accumulation).")
  }
} else {
  C_tank_steady_state <- numerator / denominator
}

# --- 結果の表示 ---
print(paste("繊維の槽内滞留時間 (s):", round(t_residence, 2)))
print(paste("無次元時間 (フーリエ数 Fo_m):", round(Fo_m, 4)))
print(paste("級数和 F(t_residence) (残存割合):", round(F_t_residence, 4)))
print(paste("繊維から除去される濃度差の割合 (1 - F):", round(fraction_removed, 4)))
print(paste("推定される定常状態の槽内(出口)DMSO濃度:", round(C_tank_steady_state, 6), "(入力濃度と同じ単位)"))